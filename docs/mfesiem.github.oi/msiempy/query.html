<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>msiempy.query API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msiempy.query</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import datetime
import abc
import copy
import json
import logging
log = logging.getLogger(&#39;msiempy&#39;)

from .base import Manager, NitroError, NitroObject
from .utils import format_esm_time, convert_to_time_obj, timerange_gettimes, parse_timedelta, divide_times

class QueryManager(Manager):
    &#34;&#34;&#34;
    Base class for query based managers : AlarmManager, EventManager
    QueryManager object can handle time_ranges and time splitting.
    &#34;&#34;&#34;
    
    DEFAULT_TIME_RANGE=&#34;CURRENT_DAY&#34;
    &#34;&#34;&#34;
    If you don&#39;t specify any `time_range`, act like if it was &#34;CURRENT_DAY&#34;.
    &#34;&#34;&#34;

    POSSIBLE_TIME_RANGE=[
            &#34;CUSTOM&#34;,
            &#34;LAST_MINUTE&#34;,
            &#34;LAST_10_MINUTES&#34;,
            &#34;LAST_30_MINUTES&#34;,
            &#34;LAST_HOUR&#34;,
            &#34;CURRENT_DAY&#34;,
            &#34;PREVIOUS_DAY&#34;,
            &#34;LAST_24_HOURS&#34;,
            &#34;LAST_2_DAYS&#34;,
            &#34;LAST_3_DAYS&#34;,
            &#34;CURRENT_WEEK&#34;,
            &#34;PREVIOUS_WEEK&#34;,
            &#34;CURRENT_MONTH&#34;,
            &#34;PREVIOUS_MONTH&#34;,
            &#34;CURRENT_QUARTER&#34;,
            &#34;PREVIOUS_QUARTER&#34;,
            &#34;CURRENT_YEAR&#34;,
            &#34;PREVIOUS_YEAR&#34;
    ]
    &#34;&#34;&#34;
    List of possible time ranges
    &#34;&#34;&#34;

    def __init__(self, time_range=None, start_time=None, end_time=None, filters=None, 
        load_async=True, requests_size=500, max_query_depth=0,
            __parent__=None, *arg, **kwargs):
        &#34;&#34;&#34;
        Abstract base class that handles the time ranges operations, loading data from the SIEM.

        Params
        ======
            time_range : Query time range. String representation of a time range. 
                See `msiempy.base.QueryManager.POSSIBLE_TIME_RANGE`
            start_time : Query starting time, can be a string or a datetime object. Parsed with dateutil.
            end_time : Query endding time, can be a string or a datetime object. Parsed with dateutil.
            filters : List of filters applied to the query
            max_query_depth : maximum number of supplement reccursions of division of the query times
                Meaning, if requests_size=500, slots=5 and max_query_depth=3, then the maximum capacity of 
                the list is (500*5)*(500*5)*(500*5) = 15625000000
            load_async : Load asynchonously the sub-queries. Defaulted to True.
            
           
        &#34;&#34;&#34;

        super().__init__(*arg, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__
        self.not_completed=False

        #self.nitro.config.default_rows #nb rows per request : eq limit/page_size = requests_size
        #self.nitro.config.max_rows #max nb rows 

        #Declaring attributes and types
        self._time_range=str()
        self._start_time=None
        self._end_time=None

        #self.filters=filters filter property setter should be called in the concrete class
        #TODO find a better solution to integrate the filter propertie

        self.load_async=load_async

        if start_time is not None and end_time is not None :
            self.start_time=start_time
            self.end_time=end_time
            self.time_range=&#39;CUSTOM&#39;
        else :
            self.time_range=time_range

        self.load_async=load_async
        self.requests_size=requests_size
        self.__init_max_query_depth__=max_query_depth
        self.query_depth_ttl=max_query_depth


    @property
    def __root_parent__(self):
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    @property
    def time_range(self):
        &#34;&#34;&#34;
        Returns the query time range. See `msiempy.query.QueryManager.POSSIBLE_TIME_RANGE`.
        Return &#39;CUSTOM&#39; if internal _time_range is None and start_time annd end_time are set.
        &#34;&#34;&#34;
        &#34;&#34;&#34;if self.start_time is not None and self.end_time is not None :
            return(&#39;CUSTOM&#39;)
        else :&#34;&#34;&#34;
        return self._time_range.upper()

    @property
    def start_time(self):
        &#34;&#34;&#34;
        Return the start time of the query in the right SIEM format.
            See `msiempy.utils.format_esm_time()`
        Use _start_time to get the datetime object
        &#34;&#34;&#34;
        return format_esm_time(self._start_time)

    @property
    def end_time(self):
        &#34;&#34;&#34;
        Return the end time of the query in the right SIEM format.
            See `msiempy.utils.format_esm_time()`
        Use _end_time to get the datetime object
        &#34;&#34;&#34;
        return format_esm_time(self._end_time)

    @time_range.setter
    def time_range(self, time_range):
        &#34;&#34;&#34;
        Set the time range of the query to the specified string value. 
        Defaulf `msiempy.queryQueryManager.DEFAULT_TIME_RANGE`.
        Note : the time range is upper cased automatically.
        Throw VallueError if unrecognized time range.
        &#34;&#34;&#34;

        if not time_range :
            self.time_range=self.DEFAULT_TIME_RANGE

        elif isinstance(time_range, str):
            time_range=time_range.upper()
            if time_range in self.POSSIBLE_TIME_RANGE :
                if time_range != &#39;CUSTOM&#39;:
                    self.start_time=None
                    self.end_time=None
                self._time_range=time_range
            else:
                raise ValueError(&#34;The time range must be in &#34;+str(self.POSSIBLE_TIME_RANGE))
        else:
            raise ValueError(&#39;time_range must be a string or None&#39;)

    
    @start_time.setter
    def start_time(self, start_time):
        &#34;&#34;&#34;
        Set the time start of the query.
        start_time can be a string or a datetime.
        If None, equivalent current_day start 00:00:00.
        &#34;&#34;&#34;
        
        
        if isinstance(start_time, str):
            self.start_time = convert_to_time_obj(start_time)
        elif isinstance(start_time, datetime.datetime):
            self._start_time = start_time
        elif start_time==None:
             self._start_time=None#raise ValueError(&#34;Time must be string or datetime object, not None&#34;)#self.start_time = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)
                
    
    @end_time.setter
    def end_time(self, end_time):
        &#34;&#34;&#34;
        Set the time end of the query.
        end_time can be a string or a datetime.
        If None, equivalent now.
        &#34;&#34;&#34;
       
        if isinstance(end_time, str):
            self.end_time = convert_to_time_obj(end_time)
        elif isinstance(end_time, datetime.datetime):
            self._end_time = end_time
        elif end_time==None:
             self._end_time=None#raise ValueError(&#34;Time must be string or datetime object, not None&#34;)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @abc.abstractproperty
    def filters(self):
        &#34;&#34;&#34; 
        Filter propertie getter. Returns a list of filters.
        #TODO find a better solution to integrate the filter propertie
        &#34;&#34;&#34;
        raise NotImplementedError()

    @filters.setter
    def filters(self, filters):
        &#34;&#34;&#34;
        Query filters property : can be a list of tuple(field, [values]) 
            or just a tuple. None value will call `msiempy.query.QueryManager.clear_filters()`
        Throws AttributeError if type not supported.
        &#34;&#34;&#34;
        
        if isinstance(filters, list):
            for f in filters :
                self.add_filter(f)

        elif isinstance(filters, tuple):
            self.add_filter(filters)

        elif filters == None :
            self.clear_filters()
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    
    @abc.abstractmethod
    def add_filter(self, filter):
        &#34;&#34;&#34;
        Method that figures out the way to add a filter to the query.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def clear_filters(self):
        &#34;&#34;&#34;
        Method that fiures out the way to remove all filters to the query.
        &#34;&#34;&#34;
        pass 

    @abc.abstractmethod
    def _load_data(self, workers):
        &#34;&#34;&#34;
        Rturn a tuple (items, completed).
        completed = True if all the data that should be load is loaded.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def load_data(self, workers=15, slots=24, delta=None):
        &#34;&#34;&#34;
        Method to load the data from the SIEM
        Split the query in defferents time slots if the query apprears not to be completed.
        Splitting is done by duplicating current object, setting different times,
        and re-loading results. First your query time is split in slots of size `delta` 
        in [performance] section of the config and launch asynchronously in queue of length `max_workers`.
        Secondly, if the sub queries are not completed, divide them in the number of `slots`, this step is
        If you&#39;re looking foe `max_query_depth`, it&#39;s define at the creation of the query manager

        Returns a QueryManager.

        Params
        -----
            requests_size : size (in items) for the individual requests.
            workers : numbre of parrallels task
           
            slots : number of time slots the query can be divided. The loading bar is 
                divided according to the number of slots
            delta : exemple : &#39;24hrs&#39;, the query will be firstly divided in chuncks according to the time delta read
                with dateutil.


        #
        &#34;&#34;&#34;

        items, completed = self._load_data(workers=workers)

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if self.query_depth_ttl &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                else :times=divide_times(start, end, slots=slots)#  IGONORING THE CONFIG ### : self.nitro.config.slots)
                
                sub_queries=list()

                #self.

                for time in times :
                    &#34;&#34;&#34;
                    &#34;&#34;&#34;
                    sub_query = copy.copy(self)
                    sub_query.__parent__=self
                    sub_query.compute_time_range=False
                    sub_query.time_range=&#39;CUSTOM&#39;
                    sub_query.start_time=time[0].isoformat()
                    sub_query.end_time=time[1].isoformat()
                    sub_query.load_async=False
                    sub_query.query_depth_ttl=self.query_depth_ttl-1
                    #sub_query.requests_size=requests_size
                    sub_queries.append(sub_query)

            
                results = self.perform(QueryManager.load_data, sub_queries, 
                    asynch=False if not self.load_async else (self.__parent__==None), progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+self.start_time+&#39; to &#39;+self.end_time+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots),
                        #IGONORING THE CONFIG ### : self.nitro.config.slots)
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query won&#39;t fully complete. Try to divide in more slots or increase the requests_size&#34;)
                    self.__root_parent__.not_completed=True

        self.data=items
        return(Manager(alist=items)) #return self ?

class TestQueryManager(QueryManager):
    pass

class QueryFilter(NitroObject):

    _possible_filters = []

    def __init__(self):
        super().__init__()

        #Setting up static constant
        &#34;&#34;&#34; Not checking dynamically the validity of the fields cause makes too much of unecessary requests
            self._possible_filters = self._get_possible_filters()
            &#34;&#34;&#34;

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return all the fields that you can filter on in a query.
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))

    @abc.abstractproperty
    def config_dict(self):
        &#34;&#34;&#34;
        Dump a filter in the right format.
        &#34;&#34;&#34;
        pass

    def refresh(self):
        &#34;&#34;&#34;
        Superclass method.
        &#34;&#34;&#34;
        log.warning(&#34;Can&#39;t refresh filter &#34;+str(self))

    @property
    def json(self):
        &#34;&#34;&#34;
        Dump the filter as a json
        &#34;&#34;&#34;
        return (json.dumps(self, indent=4, cls=NitroObject.NitroJSONEncoder))
    
    @property
    def text(self):
        &#34;&#34;&#34;
        Text representation
        &#34;&#34;&#34;
        return str(self.config_dict)

class GroupFilter(QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.
    &#34;&#34;&#34;

    def __init__(self, *filters, logic=&#39;AND&#39;) :
        &#34;&#34;&#34;
        filter : a list of filters, it can be FieldFilter or GroupFilter aka -  base.QueryFilter
        logic : &#39;AND&#39; or &#39;OR&#39; (i think)
        &#34;&#34;&#34;
        super().__init__()
        
        #Declaring attributes
        self.filters=filters
        self.logic=logic

    @property
    def config_dict(self):
        &#34;&#34;&#34;
        Could call recursively if there is other GroupFilter(s) object nested.
        Dump a filter in the right format.
        &#34;&#34;&#34;
        return({
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [f.config_dict for f in self.filters],
            &#34;logic&#34;:self.logic
            })
        
class FieldFilter(QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter. See SIEM api doc.
    Used to dump a filter in the right format.
    &#34;&#34;&#34;

    &#34;&#34;&#34;List of possibles operators        
        &#34;&#34;&#34;
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]

    &#34;&#34;&#34;List of possible type of value and the associated keyword to pass
        to
        &#34;&#34;&#34;
    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]


    def __init__(self, name, values, operator=&#39;IN&#39;) :
        &#34;&#34;&#34;
        name : field name as string
        values : list of values the field is going 
                 to be tested againts with the specified orperator
        orperator : string representing 
        &#34;&#34;&#34;
        super().__init__()
        #Declaring attributes
        self._name=str()
        self._operator=str()
        self._values=list()
        self.name = name
        self.operator = operator
        self.values = values

    @property
    def config_dict(self):
        &#34;&#34;&#34;
        Dump a filter in the right format.
        &#34;&#34;&#34;
        return ({
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            })

    @property
    def name(self):
        &#34;&#34;&#34;
        Field name property getter.
        &#34;&#34;&#34;
        return (self._name)
    
    @property
    def operator(self):
        &#34;&#34;&#34;
        Field operator property getter.
        &#34;&#34;&#34;
        return (self._operator)

    @property
    def values(self):
        &#34;&#34;&#34;
        Field values property getter.
        &#34;&#34;&#34;
        return (self._values)

    @name.setter
    def name(self, name):
        &#34;&#34;&#34;
        Could checking dynamically the validity of the fields but turned off cause it was loading to much 
        #TODO add the list of fields check in better way and STORE the list one time only. Use class property ?
        &#34;&#34;&#34;
        if True : # Not checking dynamically the validity of the fields cause makes too much of unecessary requests any(f.get(&#39;name&#39;, None) == name for f in self._possible_filters):
            self._name = name
        else:
            raise AttributeError(&#34;Illegal value for the &#34;+name+&#34; field. The filter must be in :&#34;+str([f[&#39;name&#39;] for f in self._possible_filters]))
       

    @operator.setter
    def operator(self, operator):
        &#34;&#34;&#34;
        Check the value against the list of possible operators and trow error if not present.
        &#34;&#34;&#34;
        try:
            if operator in self.POSSIBLE_OPERATORS :
                self._operator = operator
            else:
                raise AttributeError(&#34;Illegal value for the filter operator &#34;+operator+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))
        except:
            raise
        
    def add_value(self, type, **args):
        &#34;&#34;&#34;
        Add a new value to the field filter.
        
        Args could be :
            (type=&#39;EsmBasicValue&#39;,      value=&#39;a value&#39;}. or
            (type=&#39;EsmWatchlistValue&#39;,  watchlist=1)   or 
            (type=&#39;EsmVariableValue&#39;,   variable=1}  or
            (type=&#39;EsmCompoundValue&#39;,   values=[&#39;.*&#39;]}
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template is not None :
                if type_template[&#39;key&#39;] in args :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = args[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value parameter is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named parameters containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(args)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround add_value to add a EsmBasicValue
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)

    @values.setter
    def values(self, values):
        &#34;&#34;&#34;
        Set a list of values calls add_value if value is a 
            dict or calls add_basic_value if int, float or str
        
        &#34;&#34;&#34;
        for val in values :
            if isinstance(val, dict):
                self.add_value(**val)

            elif isinstance(val, (int, float, str)) :
                self.add_basic_value(val)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="msiempy.query.FieldFilter"><code class="flex name class">
<span>class <span class="ident">FieldFilter</span></span>
<span>(</span><span>name, values, operator='IN')</span>
</code></dt>
<dd>
<section class="desc"><p>Based on EsmFieldFilter. See SIEM api doc.
Used to dump a filter in the right format.</p>
<p>name : field name as string
values : list of values the field is going
to be tested againts with the specified orperator
orperator : string representing</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class FieldFilter(QueryFilter):
    &#34;&#34;&#34;
    Based on EsmFieldFilter. See SIEM api doc.
    Used to dump a filter in the right format.
    &#34;&#34;&#34;

    &#34;&#34;&#34;List of possibles operators        
        &#34;&#34;&#34;
    POSSIBLE_OPERATORS=[&#39;IN&#39;,
        &#39;NOT_IN&#39;,
        &#39;GREATER_THAN&#39;,
        &#39;LESS_THAN&#39;,
        &#39;GREATER_OR_EQUALS_THAN&#39;,
        &#39;LESS_OR_EQUALS_THAN&#39;,
        &#39;NUMERIC_EQUALS&#39;,
        &#39;NUMERIC_NOT_EQUALS&#39;,
        &#39;DOES_NOT_EQUAL&#39;,
        &#39;EQUALS&#39;,
        &#39;CONTAINS&#39;,
        &#39;DOES_NOT_CONTAIN&#39;,
        &#39;REGEX&#39;]

    &#34;&#34;&#34;List of possible type of value and the associated keyword to pass
        to
        &#34;&#34;&#34;
    POSSIBLE_VALUE_TYPES=[
            {&#39;type&#39;:&#39;EsmWatchlistValue&#39;,    &#39;key&#39;:&#39;watchlist&#39;},
            {&#39;type&#39;:&#39;EsmVariableValue&#39;,     &#39;key&#39;:&#39;variable&#39;},
            {&#39;type&#39;:&#39;EsmBasicValue&#39;,        &#39;key&#39;:&#39;value&#39;},
            {&#39;type&#39;:&#39;EsmCompoundValue&#39;,     &#39;key&#39;:&#39;values&#39;}]


    def __init__(self, name, values, operator=&#39;IN&#39;) :
        &#34;&#34;&#34;
        name : field name as string
        values : list of values the field is going 
                 to be tested againts with the specified orperator
        orperator : string representing 
        &#34;&#34;&#34;
        super().__init__()
        #Declaring attributes
        self._name=str()
        self._operator=str()
        self._values=list()
        self.name = name
        self.operator = operator
        self.values = values

    @property
    def config_dict(self):
        &#34;&#34;&#34;
        Dump a filter in the right format.
        &#34;&#34;&#34;
        return ({
            &#34;type&#34;: &#34;EsmFieldFilter&#34;,
            &#34;field&#34;: {&#34;name&#34;: self.name},
            &#34;operator&#34;: self.operator,
            &#34;values&#34;: self.values
            })

    @property
    def name(self):
        &#34;&#34;&#34;
        Field name property getter.
        &#34;&#34;&#34;
        return (self._name)
    
    @property
    def operator(self):
        &#34;&#34;&#34;
        Field operator property getter.
        &#34;&#34;&#34;
        return (self._operator)

    @property
    def values(self):
        &#34;&#34;&#34;
        Field values property getter.
        &#34;&#34;&#34;
        return (self._values)

    @name.setter
    def name(self, name):
        &#34;&#34;&#34;
        Could checking dynamically the validity of the fields but turned off cause it was loading to much 
        #TODO add the list of fields check in better way and STORE the list one time only. Use class property ?
        &#34;&#34;&#34;
        if True : # Not checking dynamically the validity of the fields cause makes too much of unecessary requests any(f.get(&#39;name&#39;, None) == name for f in self._possible_filters):
            self._name = name
        else:
            raise AttributeError(&#34;Illegal value for the &#34;+name+&#34; field. The filter must be in :&#34;+str([f[&#39;name&#39;] for f in self._possible_filters]))
       

    @operator.setter
    def operator(self, operator):
        &#34;&#34;&#34;
        Check the value against the list of possible operators and trow error if not present.
        &#34;&#34;&#34;
        try:
            if operator in self.POSSIBLE_OPERATORS :
                self._operator = operator
            else:
                raise AttributeError(&#34;Illegal value for the filter operator &#34;+operator+&#34;. The operator must be in &#34;+str(self.POSSIBLE_OPERATORS))
        except:
            raise
        
    def add_value(self, type, **args):
        &#34;&#34;&#34;
        Add a new value to the field filter.
        
        Args could be :
            (type=&#39;EsmBasicValue&#39;,      value=&#39;a value&#39;}. or
            (type=&#39;EsmWatchlistValue&#39;,  watchlist=1)   or 
            (type=&#39;EsmVariableValue&#39;,   variable=1}  or
            (type=&#39;EsmCompoundValue&#39;,   values=[&#39;.*&#39;]}
        &#34;&#34;&#34;
        try:
            type_template=None
            
            #Look for the type of the object ex EsmBasicValue
            # it&#39; used to know the type and name of value parameter we should receive next
            for possible_value_type in self.POSSIBLE_VALUE_TYPES :
                if possible_value_type[&#39;type&#39;] == type :
                    type_template=possible_value_type
                    if type != &#39;EsmBasicValue&#39; :
                        log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                    break

            #Error throwing
            if type_template is not None :
                if type_template[&#39;key&#39;] in args :
                    
                    # Adds a new value to a fields filter
                    # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                    value = args[type_template[&#39;key&#39;]]
                    if type == &#39;EsmBasicValue&#39; :
                        value=str(value)
                        #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                    self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                    #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                    
                #Error throwing
                else: raise KeyError (&#39;The valid key value parameter is not present&#39;)
            else: raise KeyError (&#39;Impossible filter&#39;)
        except KeyError as err:
            raise AttributeError(&#34;You must provide a valid named parameters containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(args)+&#34;. Additionnal indicator :&#34;+str(err) )

    def add_basic_value(self, value):
        &#34;&#34;&#34;
        Wrapper arround add_value to add a EsmBasicValue
        &#34;&#34;&#34;
        self.add_value(type=&#39;EsmBasicValue&#39;, value=value)

    @values.setter
    def values(self, values):
        &#34;&#34;&#34;
        Set a list of values calls add_value if value is a 
            dict or calls add_basic_value if int, float or str
        
        &#34;&#34;&#34;
        for val in values :
            if isinstance(val, dict):
                self.add_value(**val)

            elif isinstance(val, (int, float, str)) :
                self.add_basic_value(val)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.query.QueryFilter" href="#msiempy.query.QueryFilter">QueryFilter</a></li>
<li><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.query.FieldFilter.POSSIBLE_OPERATORS"><code class="name">var <span class="ident">POSSIBLE_OPERATORS</span></code></dt>
<dd>
<section class="desc"><p>List of possible type of value and the associated keyword to pass
to</p></section>
</dd>
<dt id="msiempy.query.FieldFilter.POSSIBLE_VALUE_TYPES"><code class="name">var <span class="ident">POSSIBLE_VALUE_TYPES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.query.FieldFilter.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<section class="desc"><p>Field name property getter.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;
    Field name property getter.
    &#34;&#34;&#34;
    return (self._name)</code></pre>
</details>
</dd>
<dt id="msiempy.query.FieldFilter.operator"><code class="name">var <span class="ident">operator</span></code></dt>
<dd>
<section class="desc"><p>Field operator property getter.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def operator(self):
    &#34;&#34;&#34;
    Field operator property getter.
    &#34;&#34;&#34;
    return (self._operator)</code></pre>
</details>
</dd>
<dt id="msiempy.query.FieldFilter.values"><code class="name">var <span class="ident">values</span></code></dt>
<dd>
<section class="desc"><p>Field values property getter.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def values(self):
    &#34;&#34;&#34;
    Field values property getter.
    &#34;&#34;&#34;
    return (self._values)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.query.FieldFilter.add_basic_value"><code class="name flex">
<span>def <span class="ident">add_basic_value</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Wrapper arround add_value to add a EsmBasicValue</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_basic_value(self, value):
    &#34;&#34;&#34;
    Wrapper arround add_value to add a EsmBasicValue
    &#34;&#34;&#34;
    self.add_value(type=&#39;EsmBasicValue&#39;, value=value)</code></pre>
</details>
</dd>
<dt id="msiempy.query.FieldFilter.add_value"><code class="name flex">
<span>def <span class="ident">add_value</span></span>(<span>self, type, **args)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a new value to the field filter.</p>
<p>Args could be :
(type='EsmBasicValue',
value='a value'}. or
(type='EsmWatchlistValue',
watchlist=1)
or
(type='EsmVariableValue',
variable=1}
or
(type='EsmCompoundValue',
values=['.*']}</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_value(self, type, **args):
    &#34;&#34;&#34;
    Add a new value to the field filter.
    
    Args could be :
        (type=&#39;EsmBasicValue&#39;,      value=&#39;a value&#39;}. or
        (type=&#39;EsmWatchlistValue&#39;,  watchlist=1)   or 
        (type=&#39;EsmVariableValue&#39;,   variable=1}  or
        (type=&#39;EsmCompoundValue&#39;,   values=[&#39;.*&#39;]}
    &#34;&#34;&#34;
    try:
        type_template=None
        
        #Look for the type of the object ex EsmBasicValue
        # it&#39; used to know the type and name of value parameter we should receive next
        for possible_value_type in self.POSSIBLE_VALUE_TYPES :
            if possible_value_type[&#39;type&#39;] == type :
                type_template=possible_value_type
                if type != &#39;EsmBasicValue&#39; :
                    log.warning(&#34;Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.&#34;)                            
                break

        #Error throwing
        if type_template is not None :
            if type_template[&#39;key&#39;] in args :
                
                # Adds a new value to a fields filter
                # Filtering query with other type of filter than &#39;EsmBasicValue&#39; is not tested.
                value = args[type_template[&#39;key&#39;]]
                if type == &#39;EsmBasicValue&#39; :
                    value=str(value)
                    #log.debug(&#39;Adding a basic value to filter (&#39;+self.text+&#39;) : &#39;+value)
                self._values.append({&#39;type&#39;:type, type_template[&#39;key&#39;]:value})
                #log.debug(&#39;The value was appended to the list: &#39;+str(self))
                
            #Error throwing
            else: raise KeyError (&#39;The valid key value parameter is not present&#39;)
        else: raise KeyError (&#39;Impossible filter&#39;)
    except KeyError as err:
        raise AttributeError(&#34;You must provide a valid named parameters containing the type and values for this filter. The type/keys must be in &#34;+str(self.POSSIBLE_VALUE_TYPES)+&#34;Can&#39;t be type=&#34;+str(type)+&#39; &#39;+str(args)+&#34;. Additionnal indicator :&#34;+str(err) )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.query.QueryFilter" href="#msiempy.query.QueryFilter">QueryFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.query.QueryFilter.NitroJSONEncoder" href="base.html#msiempy.base.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.action_refresh" href="base.html#msiempy.base.NitroObject.action_refresh">action_refresh</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.config_dict" href="#msiempy.query.QueryFilter.config_dict">config_dict</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.get_possible_filters" href="#msiempy.query.QueryFilter.get_possible_filters">get_possible_filters</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.json" href="#msiempy.query.QueryFilter.json">json</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.refresh" href="#msiempy.query.QueryFilter.refresh">refresh</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.text" href="#msiempy.query.QueryFilter.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.query.GroupFilter"><code class="flex name class">
<span>class <span class="ident">GroupFilter</span></span>
<span>(</span><span>*filters, logic='AND')</span>
</code></dt>
<dd>
<section class="desc"><p>Based on EsmFilterGroup. See SIEM api doc.
Used to dump groups of filters in the right format.</p>
<p>filter : a list of filters, it can be FieldFilter or GroupFilter aka -
base.QueryFilter
logic : 'AND' or 'OR' (i think)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class GroupFilter(QueryFilter):
    &#34;&#34;&#34;
        Based on EsmFilterGroup. See SIEM api doc.
        Used to dump groups of filters in the right format.
    &#34;&#34;&#34;

    def __init__(self, *filters, logic=&#39;AND&#39;) :
        &#34;&#34;&#34;
        filter : a list of filters, it can be FieldFilter or GroupFilter aka -  base.QueryFilter
        logic : &#39;AND&#39; or &#39;OR&#39; (i think)
        &#34;&#34;&#34;
        super().__init__()
        
        #Declaring attributes
        self.filters=filters
        self.logic=logic

    @property
    def config_dict(self):
        &#34;&#34;&#34;
        Could call recursively if there is other GroupFilter(s) object nested.
        Dump a filter in the right format.
        &#34;&#34;&#34;
        return({
            &#34;type&#34;: &#34;EsmFilterGroup&#34;,
            &#34;filters&#34;: [f.config_dict for f in self.filters],
            &#34;logic&#34;:self.logic
            })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.query.QueryFilter" href="#msiempy.query.QueryFilter">QueryFilter</a></li>
<li><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.query.GroupFilter.config_dict"><code class="name">var <span class="ident">config_dict</span></code></dt>
<dd>
<section class="desc"><p>Could call recursively if there is other GroupFilter(s) object nested.
Dump a filter in the right format.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def config_dict(self):
    &#34;&#34;&#34;
    Could call recursively if there is other GroupFilter(s) object nested.
    Dump a filter in the right format.
    &#34;&#34;&#34;
    return({
        &#34;type&#34;: &#34;EsmFilterGroup&#34;,
        &#34;filters&#34;: [f.config_dict for f in self.filters],
        &#34;logic&#34;:self.logic
        })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.query.QueryFilter" href="#msiempy.query.QueryFilter">QueryFilter</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.query.QueryFilter.NitroJSONEncoder" href="base.html#msiempy.base.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.action_refresh" href="base.html#msiempy.base.NitroObject.action_refresh">action_refresh</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.get_possible_filters" href="#msiempy.query.QueryFilter.get_possible_filters">get_possible_filters</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.json" href="#msiempy.query.QueryFilter.json">json</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.refresh" href="#msiempy.query.QueryFilter.refresh">refresh</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.text" href="#msiempy.query.QueryFilter.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.query.QueryFilter"><code class="flex name class">
<span>class <span class="ident">QueryFilter</span></span>
</code></dt>
<dd>
<section class="desc"><p>Base class for all nitro objects. All objects have a reference the single
NitroSession object that handle the esm requests</p>
<p>self.nitro.request('esm-get-times')</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class QueryFilter(NitroObject):

    _possible_filters = []

    def __init__(self):
        super().__init__()

        #Setting up static constant
        &#34;&#34;&#34; Not checking dynamically the validity of the fields cause makes too much of unecessary requests
            self._possible_filters = self._get_possible_filters()
            &#34;&#34;&#34;

    def get_possible_filters(self):
        &#34;&#34;&#34;
        Return all the fields that you can filter on in a query.
        &#34;&#34;&#34;
        return(self.nitro.request(&#39;get_possible_filters&#39;))

    @abc.abstractproperty
    def config_dict(self):
        &#34;&#34;&#34;
        Dump a filter in the right format.
        &#34;&#34;&#34;
        pass

    def refresh(self):
        &#34;&#34;&#34;
        Superclass method.
        &#34;&#34;&#34;
        log.warning(&#34;Can&#39;t refresh filter &#34;+str(self))

    @property
    def json(self):
        &#34;&#34;&#34;
        Dump the filter as a json
        &#34;&#34;&#34;
        return (json.dumps(self, indent=4, cls=NitroObject.NitroJSONEncoder))
    
    @property
    def text(self):
        &#34;&#34;&#34;
        Text representation
        &#34;&#34;&#34;
        return str(self.config_dict)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.query.GroupFilter" href="#msiempy.query.GroupFilter">GroupFilter</a></li>
<li><a title="msiempy.query.FieldFilter" href="#msiempy.query.FieldFilter">FieldFilter</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.query.QueryFilter.config_dict"><code class="name">var <span class="ident">config_dict</span></code></dt>
<dd>
<section class="desc"><p>Dump a filter in the right format.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractproperty
def config_dict(self):
    &#34;&#34;&#34;
    Dump a filter in the right format.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryFilter.json"><code class="name">var <span class="ident">json</span></code></dt>
<dd>
<section class="desc"><p>Dump the filter as a json</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def json(self):
    &#34;&#34;&#34;
    Dump the filter as a json
    &#34;&#34;&#34;
    return (json.dumps(self, indent=4, cls=NitroObject.NitroJSONEncoder))</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryFilter.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<section class="desc"><p>Text representation</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def text(self):
    &#34;&#34;&#34;
    Text representation
    &#34;&#34;&#34;
    return str(self.config_dict)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.query.QueryFilter.get_possible_filters"><code class="name flex">
<span>def <span class="ident">get_possible_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return all the fields that you can filter on in a query.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_possible_filters(self):
    &#34;&#34;&#34;
    Return all the fields that you can filter on in a query.
    &#34;&#34;&#34;
    return(self.nitro.request(&#39;get_possible_filters&#39;))</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryFilter.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Superclass method.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self):
    &#34;&#34;&#34;
    Superclass method.
    &#34;&#34;&#34;
    log.warning(&#34;Can&#39;t refresh filter &#34;+str(self))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.base.NitroObject.NitroJSONEncoder" href="base.html#msiempy.base.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.base.NitroObject.action_refresh" href="base.html#msiempy.base.NitroObject.action_refresh">action_refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.query.QueryManager"><code class="flex name class">
<span>class <span class="ident">QueryManager</span></span>
<span>(</span><span>time_range=None, start_time=None, end_time=None, filters=None, load_async=True, requests_size=500, max_query_depth=0, *arg, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for query based managers : AlarmManager, EventManager
QueryManager object can handle time_ranges and time splitting.</p>
<p>Abstract base class that handles the time ranges operations, loading data from the SIEM.</p>
<h1 id="params">Params</h1>
<pre><code>time_range : Query time range. String representation of a time range. 
    See `msiempy.base.QueryManager.POSSIBLE_TIME_RANGE`
start_time : Query starting time, can be a string or a datetime object. Parsed with dateutil.
end_time : Query endding time, can be a string or a datetime object. Parsed with dateutil.
filters : List of filters applied to the query
max_query_depth : maximum number of supplement reccursions of division of the query times
    Meaning, if requests_size=500, slots=5 and max_query_depth=3, then the maximum capacity of 
    the list is (500*5)*(500*5)*(500*5) = 15625000000
load_async : Load asynchonously the sub-queries. Defaulted to True.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class QueryManager(Manager):
    &#34;&#34;&#34;
    Base class for query based managers : AlarmManager, EventManager
    QueryManager object can handle time_ranges and time splitting.
    &#34;&#34;&#34;
    
    DEFAULT_TIME_RANGE=&#34;CURRENT_DAY&#34;
    &#34;&#34;&#34;
    If you don&#39;t specify any `time_range`, act like if it was &#34;CURRENT_DAY&#34;.
    &#34;&#34;&#34;

    POSSIBLE_TIME_RANGE=[
            &#34;CUSTOM&#34;,
            &#34;LAST_MINUTE&#34;,
            &#34;LAST_10_MINUTES&#34;,
            &#34;LAST_30_MINUTES&#34;,
            &#34;LAST_HOUR&#34;,
            &#34;CURRENT_DAY&#34;,
            &#34;PREVIOUS_DAY&#34;,
            &#34;LAST_24_HOURS&#34;,
            &#34;LAST_2_DAYS&#34;,
            &#34;LAST_3_DAYS&#34;,
            &#34;CURRENT_WEEK&#34;,
            &#34;PREVIOUS_WEEK&#34;,
            &#34;CURRENT_MONTH&#34;,
            &#34;PREVIOUS_MONTH&#34;,
            &#34;CURRENT_QUARTER&#34;,
            &#34;PREVIOUS_QUARTER&#34;,
            &#34;CURRENT_YEAR&#34;,
            &#34;PREVIOUS_YEAR&#34;
    ]
    &#34;&#34;&#34;
    List of possible time ranges
    &#34;&#34;&#34;

    def __init__(self, time_range=None, start_time=None, end_time=None, filters=None, 
        load_async=True, requests_size=500, max_query_depth=0,
            __parent__=None, *arg, **kwargs):
        &#34;&#34;&#34;
        Abstract base class that handles the time ranges operations, loading data from the SIEM.

        Params
        ======
            time_range : Query time range. String representation of a time range. 
                See `msiempy.base.QueryManager.POSSIBLE_TIME_RANGE`
            start_time : Query starting time, can be a string or a datetime object. Parsed with dateutil.
            end_time : Query endding time, can be a string or a datetime object. Parsed with dateutil.
            filters : List of filters applied to the query
            max_query_depth : maximum number of supplement reccursions of division of the query times
                Meaning, if requests_size=500, slots=5 and max_query_depth=3, then the maximum capacity of 
                the list is (500*5)*(500*5)*(500*5) = 15625000000
            load_async : Load asynchonously the sub-queries. Defaulted to True.
            
           
        &#34;&#34;&#34;

        super().__init__(*arg, **kwargs)

        #Store the query parent 
        self.__parent__=__parent__
        self.not_completed=False

        #self.nitro.config.default_rows #nb rows per request : eq limit/page_size = requests_size
        #self.nitro.config.max_rows #max nb rows 

        #Declaring attributes and types
        self._time_range=str()
        self._start_time=None
        self._end_time=None

        #self.filters=filters filter property setter should be called in the concrete class
        #TODO find a better solution to integrate the filter propertie

        self.load_async=load_async

        if start_time is not None and end_time is not None :
            self.start_time=start_time
            self.end_time=end_time
            self.time_range=&#39;CUSTOM&#39;
        else :
            self.time_range=time_range

        self.load_async=load_async
        self.requests_size=requests_size
        self.__init_max_query_depth__=max_query_depth
        self.query_depth_ttl=max_query_depth


    @property
    def __root_parent__(self):
        if self.__parent__==None:
            return self
        else :
            return self.__parent__.__root_parent__

    @property
    def time_range(self):
        &#34;&#34;&#34;
        Returns the query time range. See `msiempy.query.QueryManager.POSSIBLE_TIME_RANGE`.
        Return &#39;CUSTOM&#39; if internal _time_range is None and start_time annd end_time are set.
        &#34;&#34;&#34;
        &#34;&#34;&#34;if self.start_time is not None and self.end_time is not None :
            return(&#39;CUSTOM&#39;)
        else :&#34;&#34;&#34;
        return self._time_range.upper()

    @property
    def start_time(self):
        &#34;&#34;&#34;
        Return the start time of the query in the right SIEM format.
            See `msiempy.utils.format_esm_time()`
        Use _start_time to get the datetime object
        &#34;&#34;&#34;
        return format_esm_time(self._start_time)

    @property
    def end_time(self):
        &#34;&#34;&#34;
        Return the end time of the query in the right SIEM format.
            See `msiempy.utils.format_esm_time()`
        Use _end_time to get the datetime object
        &#34;&#34;&#34;
        return format_esm_time(self._end_time)

    @time_range.setter
    def time_range(self, time_range):
        &#34;&#34;&#34;
        Set the time range of the query to the specified string value. 
        Defaulf `msiempy.queryQueryManager.DEFAULT_TIME_RANGE`.
        Note : the time range is upper cased automatically.
        Throw VallueError if unrecognized time range.
        &#34;&#34;&#34;

        if not time_range :
            self.time_range=self.DEFAULT_TIME_RANGE

        elif isinstance(time_range, str):
            time_range=time_range.upper()
            if time_range in self.POSSIBLE_TIME_RANGE :
                if time_range != &#39;CUSTOM&#39;:
                    self.start_time=None
                    self.end_time=None
                self._time_range=time_range
            else:
                raise ValueError(&#34;The time range must be in &#34;+str(self.POSSIBLE_TIME_RANGE))
        else:
            raise ValueError(&#39;time_range must be a string or None&#39;)

    
    @start_time.setter
    def start_time(self, start_time):
        &#34;&#34;&#34;
        Set the time start of the query.
        start_time can be a string or a datetime.
        If None, equivalent current_day start 00:00:00.
        &#34;&#34;&#34;
        
        
        if isinstance(start_time, str):
            self.start_time = convert_to_time_obj(start_time)
        elif isinstance(start_time, datetime.datetime):
            self._start_time = start_time
        elif start_time==None:
             self._start_time=None#raise ValueError(&#34;Time must be string or datetime object, not None&#34;)#self.start_time = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)
                
    
    @end_time.setter
    def end_time(self, end_time):
        &#34;&#34;&#34;
        Set the time end of the query.
        end_time can be a string or a datetime.
        If None, equivalent now.
        &#34;&#34;&#34;
       
        if isinstance(end_time, str):
            self.end_time = convert_to_time_obj(end_time)
        elif isinstance(end_time, datetime.datetime):
            self._end_time = end_time
        elif end_time==None:
             self._end_time=None#raise ValueError(&#34;Time must be string or datetime object, not None&#34;)
        else:
            raise ValueError(&#34;Time must be string or datetime object.&#34;)

    @abc.abstractproperty
    def filters(self):
        &#34;&#34;&#34; 
        Filter propertie getter. Returns a list of filters.
        #TODO find a better solution to integrate the filter propertie
        &#34;&#34;&#34;
        raise NotImplementedError()

    @filters.setter
    def filters(self, filters):
        &#34;&#34;&#34;
        Query filters property : can be a list of tuple(field, [values]) 
            or just a tuple. None value will call `msiempy.query.QueryManager.clear_filters()`
        Throws AttributeError if type not supported.
        &#34;&#34;&#34;
        
        if isinstance(filters, list):
            for f in filters :
                self.add_filter(f)

        elif isinstance(filters, tuple):
            self.add_filter(filters)

        elif filters == None :
            self.clear_filters()
        
        else :
            raise AttributeError(&#34;Illegal type for the filter object, it must be a list, a tuple or None.&#34;)

    
    @abc.abstractmethod
    def add_filter(self, filter):
        &#34;&#34;&#34;
        Method that figures out the way to add a filter to the query.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def clear_filters(self):
        &#34;&#34;&#34;
        Method that fiures out the way to remove all filters to the query.
        &#34;&#34;&#34;
        pass 

    @abc.abstractmethod
    def _load_data(self, workers):
        &#34;&#34;&#34;
        Rturn a tuple (items, completed).
        completed = True if all the data that should be load is loaded.
        &#34;&#34;&#34;
        pass

    @abc.abstractmethod
    def load_data(self, workers=15, slots=24, delta=None):
        &#34;&#34;&#34;
        Method to load the data from the SIEM
        Split the query in defferents time slots if the query apprears not to be completed.
        Splitting is done by duplicating current object, setting different times,
        and re-loading results. First your query time is split in slots of size `delta` 
        in [performance] section of the config and launch asynchronously in queue of length `max_workers`.
        Secondly, if the sub queries are not completed, divide them in the number of `slots`, this step is
        If you&#39;re looking foe `max_query_depth`, it&#39;s define at the creation of the query manager

        Returns a QueryManager.

        Params
        -----
            requests_size : size (in items) for the individual requests.
            workers : numbre of parrallels task
           
            slots : number of time slots the query can be divided. The loading bar is 
                divided according to the number of slots
            delta : exemple : &#39;24hrs&#39;, the query will be firstly divided in chuncks according to the time delta read
                with dateutil.


        #
        &#34;&#34;&#34;

        items, completed = self._load_data(workers=workers)

        if not completed :
            #If not completed the query is split and items aren&#39;t actually used

            if self.query_depth_ttl &gt; 0 :
                #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

                if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                    start, end = timerange_gettimes(self.time_range)
                else :
                    start, end = self.start_time, self.end_time

                if self.__parent__ == None and isinstance(delta, str) :
                    times=divide_times(start, end, delta=parse_timedelta(delta))
                else :times=divide_times(start, end, slots=slots)#  IGONORING THE CONFIG ### : self.nitro.config.slots)
                
                sub_queries=list()

                #self.

                for time in times :
                    &#34;&#34;&#34;
                    &#34;&#34;&#34;
                    sub_query = copy.copy(self)
                    sub_query.__parent__=self
                    sub_query.compute_time_range=False
                    sub_query.time_range=&#39;CUSTOM&#39;
                    sub_query.start_time=time[0].isoformat()
                    sub_query.end_time=time[1].isoformat()
                    sub_query.load_async=False
                    sub_query.query_depth_ttl=self.query_depth_ttl-1
                    #sub_query.requests_size=requests_size
                    sub_queries.append(sub_query)

            
                results = self.perform(QueryManager.load_data, sub_queries, 
                    asynch=False if not self.load_async else (self.__parent__==None), progress=self.__parent__==None, 
                    message=&#39;Loading data from &#39;+self.start_time+&#39; to &#39;+self.end_time+&#39;. In {} slots&#39;.format(len(times)),
                    func_args=dict(slots=slots),
                        #IGONORING THE CONFIG ### : self.nitro.config.slots)
                    workers=workers)

                #Flatten the list of lists in a list
                items=[item for sublist in results for item in sublist]
                
            else :
                if not self.__root_parent__.not_completed :
                    log.warning(&#34;The query won&#39;t fully complete. Try to divide in more slots or increase the requests_size&#34;)
                    self.__root_parent__.not_completed=True

        self.data=items
        return(Manager(alist=items)) #return self ?</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.base.Manager" href="base.html#msiempy.base.Manager">Manager</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="msiempy.query.TestQueryManager" href="#msiempy.query.TestQueryManager">TestQueryManager</a></li>
<li><a title="msiempy.event.EventManager" href="event.html#msiempy.event.EventManager">EventManager</a></li>
<li><a title="msiempy.alarm.AlarmManager" href="alarm.html#msiempy.alarm.AlarmManager">AlarmManager</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="msiempy.query.QueryManager.DEFAULT_TIME_RANGE"><code class="name">var <span class="ident">DEFAULT_TIME_RANGE</span></code></dt>
<dd>
<section class="desc"><p>If you don't specify any <code>time_range</code>, act like if it was "CURRENT_DAY".</p></section>
</dd>
<dt id="msiempy.query.QueryManager.POSSIBLE_TIME_RANGE"><code class="name">var <span class="ident">POSSIBLE_TIME_RANGE</span></code></dt>
<dd>
<section class="desc"><p>List of possible time ranges</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="msiempy.query.QueryManager.end_time"><code class="name">var <span class="ident">end_time</span></code></dt>
<dd>
<section class="desc"><p>Return the end time of the query in the right SIEM format.
See <a title="msiempy.utils.format_esm_time" href="utils.html#msiempy.utils.format_esm_time"><code>format_esm_time()</code></a>
Use _end_time to get the datetime object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def end_time(self):
    &#34;&#34;&#34;
    Return the end time of the query in the right SIEM format.
        See `msiempy.utils.format_esm_time()`
    Use _end_time to get the datetime object
    &#34;&#34;&#34;
    return format_esm_time(self._end_time)</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryManager.filters"><code class="name">var <span class="ident">filters</span></code></dt>
<dd>
<section class="desc"><p>Filter propertie getter. Returns a list of filters.</p>
<h1 id="todo-find-a-better-solution-to-integrate-the-filter-propertie">TODO find a better solution to integrate the filter propertie</h1></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractproperty
def filters(self):
    &#34;&#34;&#34; 
    Filter propertie getter. Returns a list of filters.
    #TODO find a better solution to integrate the filter propertie
    &#34;&#34;&#34;
    raise NotImplementedError()</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryManager.start_time"><code class="name">var <span class="ident">start_time</span></code></dt>
<dd>
<section class="desc"><p>Return the start time of the query in the right SIEM format.
See <a title="msiempy.utils.format_esm_time" href="utils.html#msiempy.utils.format_esm_time"><code>format_esm_time()</code></a>
Use _start_time to get the datetime object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def start_time(self):
    &#34;&#34;&#34;
    Return the start time of the query in the right SIEM format.
        See `msiempy.utils.format_esm_time()`
    Use _start_time to get the datetime object
    &#34;&#34;&#34;
    return format_esm_time(self._start_time)</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryManager.time_range"><code class="name">var <span class="ident">time_range</span></code></dt>
<dd>
<section class="desc"><p>Returns the query time range. See <a title="msiempy.query.QueryManager.POSSIBLE_TIME_RANGE" href="#msiempy.query.QueryManager.POSSIBLE_TIME_RANGE"><code>QueryManager.POSSIBLE_TIME_RANGE</code></a>.
Return 'CUSTOM' if internal _time_range is None and start_time annd end_time are set.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def time_range(self):
    &#34;&#34;&#34;
    Returns the query time range. See `msiempy.query.QueryManager.POSSIBLE_TIME_RANGE`.
    Return &#39;CUSTOM&#39; if internal _time_range is None and start_time annd end_time are set.
    &#34;&#34;&#34;
    &#34;&#34;&#34;if self.start_time is not None and self.end_time is not None :
        return(&#39;CUSTOM&#39;)
    else :&#34;&#34;&#34;
    return self._time_range.upper()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="msiempy.query.QueryManager.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, filter)</span>
</code></dt>
<dd>
<section class="desc"><p>Method that figures out the way to add a filter to the query.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractmethod
def add_filter(self, filter):
    &#34;&#34;&#34;
    Method that figures out the way to add a filter to the query.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryManager.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Method that fiures out the way to remove all filters to the query.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractmethod
def clear_filters(self):
    &#34;&#34;&#34;
    Method that fiures out the way to remove all filters to the query.
    &#34;&#34;&#34;
    pass </code></pre>
</details>
</dd>
<dt id="msiempy.query.QueryManager.load_data"><code class="name flex">
<span>def <span class="ident">load_data</span></span>(<span>self, workers=15, slots=24, delta=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Method to load the data from the SIEM
Split the query in defferents time slots if the query apprears not to be completed.
Splitting is done by duplicating current object, setting different times,
and re-loading results. First your query time is split in slots of size <code>delta</code>
in [performance] section of the config and launch asynchronously in queue of length <code>max_workers</code>.
Secondly, if the sub queries are not completed, divide them in the number of <code>slots</code>, this step is
If you're looking foe <code>max_query_depth</code>, it's define at the creation of the query manager</p>
<p>Returns a QueryManager.</p>
<h2 id="params">Params</h2>
<pre><code>requests_size : size (in items) for the individual requests.
workers : numbre of parrallels task

slots : number of time slots the query can be divided. The loading bar is 
    divided according to the number of slots
delta : exemple : '24hrs', the query will be firstly divided in chuncks according to the time delta read
    with dateutil.
</code></pre>
<h1 id="_1"></h1></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@abc.abstractmethod
def load_data(self, workers=15, slots=24, delta=None):
    &#34;&#34;&#34;
    Method to load the data from the SIEM
    Split the query in defferents time slots if the query apprears not to be completed.
    Splitting is done by duplicating current object, setting different times,
    and re-loading results. First your query time is split in slots of size `delta` 
    in [performance] section of the config and launch asynchronously in queue of length `max_workers`.
    Secondly, if the sub queries are not completed, divide them in the number of `slots`, this step is
    If you&#39;re looking foe `max_query_depth`, it&#39;s define at the creation of the query manager

    Returns a QueryManager.

    Params
    -----
        requests_size : size (in items) for the individual requests.
        workers : numbre of parrallels task
       
        slots : number of time slots the query can be divided. The loading bar is 
            divided according to the number of slots
        delta : exemple : &#39;24hrs&#39;, the query will be firstly divided in chuncks according to the time delta read
            with dateutil.


    #
    &#34;&#34;&#34;

    items, completed = self._load_data(workers=workers)

    if not completed :
        #If not completed the query is split and items aren&#39;t actually used

        if self.query_depth_ttl &gt; 0 :
            #log.info(&#34;The query data couldn&#39;t be loaded in one request, separating it in sub-queries...&#34;)

            if self.time_range != &#39;CUSTOM&#39;: #can raise a NotImplementedError if unsupported time_range
                start, end = timerange_gettimes(self.time_range)
            else :
                start, end = self.start_time, self.end_time

            if self.__parent__ == None and isinstance(delta, str) :
                times=divide_times(start, end, delta=parse_timedelta(delta))
            else :times=divide_times(start, end, slots=slots)#  IGONORING THE CONFIG ### : self.nitro.config.slots)
            
            sub_queries=list()

            #self.

            for time in times :
                &#34;&#34;&#34;
                &#34;&#34;&#34;
                sub_query = copy.copy(self)
                sub_query.__parent__=self
                sub_query.compute_time_range=False
                sub_query.time_range=&#39;CUSTOM&#39;
                sub_query.start_time=time[0].isoformat()
                sub_query.end_time=time[1].isoformat()
                sub_query.load_async=False
                sub_query.query_depth_ttl=self.query_depth_ttl-1
                #sub_query.requests_size=requests_size
                sub_queries.append(sub_query)

        
            results = self.perform(QueryManager.load_data, sub_queries, 
                asynch=False if not self.load_async else (self.__parent__==None), progress=self.__parent__==None, 
                message=&#39;Loading data from &#39;+self.start_time+&#39; to &#39;+self.end_time+&#39;. In {} slots&#39;.format(len(times)),
                func_args=dict(slots=slots),
                    #IGONORING THE CONFIG ### : self.nitro.config.slots)
                workers=workers)

            #Flatten the list of lists in a list
            items=[item for sublist in results for item in sublist]
            
        else :
            if not self.__root_parent__.not_completed :
                log.warning(&#34;The query won&#39;t fully complete. Try to divide in more slots or increase the requests_size&#34;)
                self.__root_parent__.not_completed=True

    self.data=items
    return(Manager(alist=items)) #return self ?</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.base.Manager" href="base.html#msiempy.base.Manager">Manager</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.base.Manager.NitroJSONEncoder" href="base.html#msiempy.base.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.base.Manager.SELECTED" href="base.html#msiempy.base.Manager.SELECTED">SELECTED</a></code></li>
<li><code><a title="msiempy.base.Manager.action_refresh" href="base.html#msiempy.base.NitroObject.action_refresh">action_refresh</a></code></li>
<li><code><a title="msiempy.base.Manager.clear" href="base.html#msiempy.base.Manager.clear">clear</a></code></li>
<li><code><a title="msiempy.base.Manager.get_text" href="base.html#msiempy.base.Manager.get_text">get_text</a></code></li>
<li><code><a title="msiempy.base.Manager.json" href="base.html#msiempy.base.NitroObject.json">json</a></code></li>
<li><code><a title="msiempy.base.Manager.perform" href="base.html#msiempy.base.Manager.perform">perform</a></code></li>
<li><code><a title="msiempy.base.Manager.refresh" href="base.html#msiempy.base.Manager.refresh">refresh</a></code></li>
<li><code><a title="msiempy.base.Manager.search" href="base.html#msiempy.base.Manager.search">search</a></code></li>
<li><code><a title="msiempy.base.Manager.selected_items" href="base.html#msiempy.base.Manager.selected_items">selected_items</a></code></li>
<li><code><a title="msiempy.base.Manager.text" href="base.html#msiempy.base.NitroObject.text">text</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="msiempy.query.TestQueryManager"><code class="flex name class">
<span>class <span class="ident">TestQueryManager</span></span>
<span>(</span><span>time_range=None, start_time=None, end_time=None, filters=None, load_async=True, requests_size=500, max_query_depth=0, *arg, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base class for query based managers : AlarmManager, EventManager
QueryManager object can handle time_ranges and time splitting.</p>
<p>Abstract base class that handles the time ranges operations, loading data from the SIEM.</p>
<h1 id="params">Params</h1>
<pre><code>time_range : Query time range. String representation of a time range. 
    See `msiempy.base.QueryManager.POSSIBLE_TIME_RANGE`
start_time : Query starting time, can be a string or a datetime object. Parsed with dateutil.
end_time : Query endding time, can be a string or a datetime object. Parsed with dateutil.
filters : List of filters applied to the query
max_query_depth : maximum number of supplement reccursions of division of the query times
    Meaning, if requests_size=500, slots=5 and max_query_depth=3, then the maximum capacity of 
    the list is (500*5)*(500*5)*(500*5) = 15625000000
load_async : Load asynchonously the sub-queries. Defaulted to True.
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class TestQueryManager(QueryManager):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="msiempy.query.QueryManager" href="#msiempy.query.QueryManager">QueryManager</a></li>
<li><a title="msiempy.base.Manager" href="base.html#msiempy.base.Manager">Manager</a></li>
<li>collections.UserList</li>
<li>collections.abc.MutableSequence</li>
<li>collections.abc.Sequence</li>
<li>collections.abc.Reversible</li>
<li>collections.abc.Collection</li>
<li>collections.abc.Sized</li>
<li>collections.abc.Iterable</li>
<li>collections.abc.Container</li>
<li><a title="msiempy.base.NitroObject" href="base.html#msiempy.base.NitroObject">NitroObject</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="msiempy.query.QueryManager" href="#msiempy.query.QueryManager">QueryManager</a></b></code>:
<ul class="hlist">
<li><code><a title="msiempy.query.QueryManager.DEFAULT_TIME_RANGE" href="#msiempy.query.QueryManager.DEFAULT_TIME_RANGE">DEFAULT_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.query.QueryManager.NitroJSONEncoder" href="base.html#msiempy.base.NitroObject.NitroJSONEncoder">NitroJSONEncoder</a></code></li>
<li><code><a title="msiempy.query.QueryManager.POSSIBLE_TIME_RANGE" href="#msiempy.query.QueryManager.POSSIBLE_TIME_RANGE">POSSIBLE_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.query.QueryManager.SELECTED" href="base.html#msiempy.base.Manager.SELECTED">SELECTED</a></code></li>
<li><code><a title="msiempy.query.QueryManager.action_refresh" href="base.html#msiempy.base.NitroObject.action_refresh">action_refresh</a></code></li>
<li><code><a title="msiempy.query.QueryManager.add_filter" href="#msiempy.query.QueryManager.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.query.QueryManager.clear" href="base.html#msiempy.base.Manager.clear">clear</a></code></li>
<li><code><a title="msiempy.query.QueryManager.clear_filters" href="#msiempy.query.QueryManager.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.query.QueryManager.end_time" href="#msiempy.query.QueryManager.end_time">end_time</a></code></li>
<li><code><a title="msiempy.query.QueryManager.filters" href="#msiempy.query.QueryManager.filters">filters</a></code></li>
<li><code><a title="msiempy.query.QueryManager.get_text" href="base.html#msiempy.base.Manager.get_text">get_text</a></code></li>
<li><code><a title="msiempy.query.QueryManager.json" href="base.html#msiempy.base.NitroObject.json">json</a></code></li>
<li><code><a title="msiempy.query.QueryManager.load_data" href="#msiempy.query.QueryManager.load_data">load_data</a></code></li>
<li><code><a title="msiempy.query.QueryManager.perform" href="base.html#msiempy.base.Manager.perform">perform</a></code></li>
<li><code><a title="msiempy.query.QueryManager.refresh" href="base.html#msiempy.base.Manager.refresh">refresh</a></code></li>
<li><code><a title="msiempy.query.QueryManager.search" href="base.html#msiempy.base.Manager.search">search</a></code></li>
<li><code><a title="msiempy.query.QueryManager.selected_items" href="base.html#msiempy.base.Manager.selected_items">selected_items</a></code></li>
<li><code><a title="msiempy.query.QueryManager.start_time" href="#msiempy.query.QueryManager.start_time">start_time</a></code></li>
<li><code><a title="msiempy.query.QueryManager.text" href="base.html#msiempy.base.NitroObject.text">text</a></code></li>
<li><code><a title="msiempy.query.QueryManager.time_range" href="#msiempy.query.QueryManager.time_range">time_range</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msiempy" href="index.html">msiempy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="msiempy.query.FieldFilter" href="#msiempy.query.FieldFilter">FieldFilter</a></code></h4>
<ul class="">
<li><code><a title="msiempy.query.FieldFilter.POSSIBLE_OPERATORS" href="#msiempy.query.FieldFilter.POSSIBLE_OPERATORS">POSSIBLE_OPERATORS</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.POSSIBLE_VALUE_TYPES" href="#msiempy.query.FieldFilter.POSSIBLE_VALUE_TYPES">POSSIBLE_VALUE_TYPES</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.add_basic_value" href="#msiempy.query.FieldFilter.add_basic_value">add_basic_value</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.add_value" href="#msiempy.query.FieldFilter.add_value">add_value</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.name" href="#msiempy.query.FieldFilter.name">name</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.operator" href="#msiempy.query.FieldFilter.operator">operator</a></code></li>
<li><code><a title="msiempy.query.FieldFilter.values" href="#msiempy.query.FieldFilter.values">values</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.query.GroupFilter" href="#msiempy.query.GroupFilter">GroupFilter</a></code></h4>
<ul class="">
<li><code><a title="msiempy.query.GroupFilter.config_dict" href="#msiempy.query.GroupFilter.config_dict">config_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.query.QueryFilter" href="#msiempy.query.QueryFilter">QueryFilter</a></code></h4>
<ul class="">
<li><code><a title="msiempy.query.QueryFilter.config_dict" href="#msiempy.query.QueryFilter.config_dict">config_dict</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.get_possible_filters" href="#msiempy.query.QueryFilter.get_possible_filters">get_possible_filters</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.json" href="#msiempy.query.QueryFilter.json">json</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.refresh" href="#msiempy.query.QueryFilter.refresh">refresh</a></code></li>
<li><code><a title="msiempy.query.QueryFilter.text" href="#msiempy.query.QueryFilter.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.query.QueryManager" href="#msiempy.query.QueryManager">QueryManager</a></code></h4>
<ul class="two-column">
<li><code><a title="msiempy.query.QueryManager.DEFAULT_TIME_RANGE" href="#msiempy.query.QueryManager.DEFAULT_TIME_RANGE">DEFAULT_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.query.QueryManager.POSSIBLE_TIME_RANGE" href="#msiempy.query.QueryManager.POSSIBLE_TIME_RANGE">POSSIBLE_TIME_RANGE</a></code></li>
<li><code><a title="msiempy.query.QueryManager.add_filter" href="#msiempy.query.QueryManager.add_filter">add_filter</a></code></li>
<li><code><a title="msiempy.query.QueryManager.clear_filters" href="#msiempy.query.QueryManager.clear_filters">clear_filters</a></code></li>
<li><code><a title="msiempy.query.QueryManager.end_time" href="#msiempy.query.QueryManager.end_time">end_time</a></code></li>
<li><code><a title="msiempy.query.QueryManager.filters" href="#msiempy.query.QueryManager.filters">filters</a></code></li>
<li><code><a title="msiempy.query.QueryManager.load_data" href="#msiempy.query.QueryManager.load_data">load_data</a></code></li>
<li><code><a title="msiempy.query.QueryManager.start_time" href="#msiempy.query.QueryManager.start_time">start_time</a></code></li>
<li><code><a title="msiempy.query.QueryManager.time_range" href="#msiempy.query.QueryManager.time_range">time_range</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="msiempy.query.TestQueryManager" href="#msiempy.query.TestQueryManager">TestQueryManager</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>